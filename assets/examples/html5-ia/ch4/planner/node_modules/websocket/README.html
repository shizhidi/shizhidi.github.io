<h1 id="WebSocket_Client_&amp;_Server_Implementation_for_Node">WebSocket Client &amp; Server Implementation for Node</h1><h2 id="Browser_Support">Browser Support</h2><ul>
<li>Firefox 7 (Old) (Protocol Version 8)</li>
<li>Firefox 8 (Stable) (Protocol Version 8)</li>
<li>Firefox 9 (Beta) (Protocol Version 8)</li>
<li>Chrome 14 (Old) (Protocol Version 8)</li>
<li>Chrome 15 (Stable) (Protocol Version 8)</li>
<li>Chrome 16 (Beta) (Protocol Version 13)</li>
</ul>
<p><strong><em>Safari is not supported at this time as it uses an old draft of WebSockets</em></strong></p>
<p><em>WARNING: This is a library implementing only the most recent draft of the WebSocket protocol.  It will not work with most production browsers until new versions are released that support it.</em></p>
<p>I made a decision early on to explicitly avoid maintaining multiple slightly different copies of the same code just to support the browsers currently in the wild.  The major browsers that support WebSocket are on a rapid-release schedule (with the exception of Safari) and once the final version of the protocol is ratified by the IETF, it won’t be long before support in the wild stabilizes on that version.  My client application is in Flash/ActionScript 3, so for my purposes I’m not dependent on the browser implementations.  <em>I made an exception to my stated intention here to support protocol version 13, since only one minor thing changed and it was trivial to handle conditionally.</em>  The library now interoperates with other clients and servers implementing drafts -08 through -17.</p>
<p><strong><em>If you need to simultaneously support older production browser versions that had implemented draft-75/draft-76/draft-00, take a look here: <a href="https://gist.github.com/1219165">https://gist.github.com/1219165</a></em></strong></p>
<p><strong>Note about FireFox:  Firefox uses a prefixed constructor name in its client side JavaScript, MozWebSocket(), which will be changed to WebSocket() presumably when the WebSocket RFC has been released.</strong></p>
<p>For a WebSocket protocol 8 (draft-10) client written in ActionScript 3 see my <a href="https://github.com/Worlize/AS3WebSocket">AS3WebScocket</a> project.</p>
<h2 id="Overview">Overview</h2><p>This code is relatively new, though it is used in production on <a href="http://worlize.com">http://worlize.com</a> and seems to be stable.  Your mileage may vary.</p>
<p>This is a pure JavaScript implementation of the WebSocket protocol versions 8 and 13 for Node.  There are some example client and server applications that implement various interoperability testing protocols in the “test” folder.</p>
<p><strong><em>Note about Draft Naming and versioning:</em></strong> <em>The draft number (draft-17) does not necessarily correspond to the protocol version (13.)  Many times a new draft is released with only editorial changes, in which case the protocol version is not incremented.  The drafts are interoperable within a protocol version, with only editorial changes.  The current implementation of WebSocket-Node works protocol version 8 (drafts -08 through -12) and protocol version 13 (drafts -13 through -17.)</em></p>
<p>If you’re looking for a version supporting draft-07 or draft-06, see the draft-07 or draft-06 branches.  Previous draft branches will not be maintained, as I plan to track each subsequent draft of the protocol until it’s finalized, and will ultimately be supporting <em>only</em> the final draft.</p>
<p><strong>Supported with the following node versions:</strong></p>
<ul>
<li>0.4.12</li>
<li>0.6.2</li>
</ul>
<p>It may work in earlier or later versions but I’m not actively testing it outside of the listed versions.  YMMV.</p>
<h1 id="Documentation">Documentation</h1><p>For more complete documentation, see the <a href="https://github.com/Worlize/WebSocket-Node/wiki/Documentation">Documentation Wiki</a>.</p>
<h2 id="Installation">Installation</h2><p>In your project root:</p>
<pre><code>$ npm <span class="keyword">install</span> websocket
</code></pre><p>Then in your code:</p>
<pre><code><span class="reserved">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;
<span class="reserved">var</span> WebSocketClient = <span class="built_in">require</span>(<span class="string">'websocket'</span>).client;
<span class="reserved">var</span> WebSocketFrame  = <span class="built_in">require</span>(<span class="string">'websocket'</span>).frame;
<span class="reserved">var</span> WebSocketRouter = <span class="built_in">require</span>(<span class="string">'websocket'</span>).router;
</code></pre><h2 id="Current_Features:">Current Features:</h2><ul>
<li>Licensed under the Apache License, Version 2.0</li>
<li>Protocol version “8” and “13” (Draft-08 through Draft-17) framing and handshake</li>
<li>Can handle/aggregate received fragmented messages</li>
<li>Can fragment outgoing messages</li>
<li>Router to mount multiple applications to various path and protocol combinations</li>
<li>TLS supported for outbound connections via WebSocketClient</li>
<li>Cookie setting and parsing</li>
<li>Tunable settings<ul>
<li>Max Receivable Frame Size</li>
<li>Max Aggregate ReceivedMessage Size</li>
<li>Whether to fragment outgoing messages</li>
<li>Fragmentation chunk size for outgoing messages</li>
<li>Whether to automatically send ping frames for the purposes of keepalive</li>
<li>Keep-alive ping interval</li>
<li>Whether or not to automatically assemble received fragments (allows application to handle individual fragments directly)</li>
<li>How long to wait after sending a close frame for acknowledgment before closing the socket.</li>
</ul>
</li>
</ul>
<h2 id="Known_Issues/Missing_Features:">Known Issues/Missing Features:</h2><ul>
<li>No API for user-provided protocol extensions.</li>
<li>Haven’t tested TLS for the Server.  (Perhaps this is handled automatically by attaching the WebSocket server to a https.createServer instead of http.createServer?)</li>
</ul>
<h1 id="Usage_Examples">Usage Examples</h1><h2 id="Server_Example">Server Example</h2><p>Here’s a short example showing a server that echos back anything sent to it, whether utf-8 or binary.</p>
<pre><code>#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>{
    <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">" Received request for "</span> + request.url);
    response.writeHead(<span class="number">404</span>);
    response.end();
});
server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">" Server is listening on port 8080"</span>);
});

wsServer = <span class="keyword">new</span> WebSocketServer({
    httpServer: server,
    <span class="comment">// You should not use autoAcceptConnections for production</span>
    <span class="comment">// applications, as it defeats all standard cross-origin protection</span>
    <span class="comment">// facilities built into the protocol and the browser.  You should</span>
    <span class="comment">// *always* verify the connection's origin and decide whether or not</span>
    <span class="comment">// to accept it.</span>
    autoAcceptConnections: <span class="literal">false</span>
});

wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>{
    <span class="keyword">if</span> (!originIsAllowed(request.origin)) {
      <span class="comment">// Make sure we only accept requests from an allowed origin</span>
      request.reject();
      <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">" Connection from origin "</span> + request.origin + <span class="string">" rejected."</span>);
      <span class="keyword">return</span>;
    }

    <span class="keyword">var</span> connection = request.accept(<span class="literal">null</span>, request.origin);
    <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">" Connection accepted."</span>);
    connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>{
        <span class="keyword">if</span> (message.type === <span class="string">'utf8'</span>) {
            <span class="built_in">console</span>.log(<span class="string">"Received Message: "</span> + message.utf8Data);
            connection.sendUTF(message.utf8Data);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (message.type === <span class="string">'binary'</span>) {
            <span class="built_in">console</span>.log(<span class="string">"Received Binary Message of "</span> + message.binaryData.length + <span class="string">" bytes"</span>);
            connection.sendBytes(message.binaryData);
        }
    });
    connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>{
        <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">" Peer "</span> + connection.remoteAddress + <span class="string">" disconnected."</span>);
    });
});

<span class="function"><span class="keyword">function</span> <span class="title">originIsAllowed</span>(<span class="params">origin</span>) </span>{
  <span class="comment">// put logic here to detect whether the specified origin is allowed.</span>
  <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h2 id="Client_Example">Client Example</h2><p>This is a simple example client that will print out any utf-8 messages it receives on the console, and periodically sends a random number.</p>
<p><em>This code demonstrates a client in Node.js, not in the browser</em></p>
<pre><code>#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> WebSocketClient = <span class="built_in">require</span>(<span class="string">'websocket'</span>).client;

<span class="keyword">var</span> client = <span class="keyword">new</span> WebSocketClient();

client.on(<span class="string">'connectFailed'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"Connect Error: "</span> + error.toString());
});

client.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"WebSocket client connected"</span>);
    connection.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"Connection Error: "</span> + error.toString());
    });
    connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"echo-protocol Connection Closed"</span>);
    })
    connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>{
        <span class="keyword">if</span> (message.type === <span class="string">'utf8'</span>) {
            <span class="built_in">console</span>.log(<span class="string">"Received: '"</span> + message.utf8Data + <span class="string">"'"</span>);
        }
    });

    <span class="function"><span class="keyword">function</span> <span class="title">sendNumber</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span> (connection.connected) {
            <span class="keyword">var</span> number = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">0xFFFFFF</span>);
            connection.sendUTF(number.toString());
            setTimeout(sendNumber, <span class="number">1000</span>);
        }
    }
    sendNumber();
});

client.connect(<span class="string">"ws://localhost:8080/"</span>, <span class="string">'echo-protocol'</span>);
</code></pre><h2 id="Request_Router_Example">Request Router Example</h2><p>For an example of using the request router, see <code>libwebsockets-test-server.js</code> in the <code>test</code> folder.</p>
<h2 id="Resources">Resources</h2><p>A presentation on the state of the WebSockets protocol that I gave on July 23, 2011 at the LA Hacker News meetup.  <a href="http://www.scribd.com/doc/60898569/WebSockets-The-Real-Time-Web-Delivered">WebSockets: The Real-Time Web, Delivered</a></p>
