<h1 id="node-uuid">node-uuid</h1><p>Simple, fast generation of <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC4122</a> UUIDS.</p>
<p>Features:</p>
<ul>
<li>Generate RFC4122 version 1 or version 4 UUIDs</li>
<li>Runs in node.js and all browsers.</li>
<li>Cryptographically strong random # generation on supporting platforms</li>
<li>1.1K minified and gzip’ed</li>
</ul>
<h2 id="Getting_Started">Getting Started</h2><p>Install it in your browser:</p>
<pre><code class="html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"uuid.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>
<p>Or in node.js:</p>
<pre><code>npm install <span class="keyword">node</span>-<span class="built_in">uuid</span>
</code></pre><pre><code class="javascript"><span class="keyword">var</span> uuid = <span class="built_in">require</span>(<span class="string">'node-uuid'</span>);
</code></pre>
<p>Then create some ids …</p>
<pre><code class="javascript"><span class="comment">// Generate a v1 (time-based) id</span>
uuid.v1(); <span class="comment">// -&gt; '6c84fb90-12c4-11e1-840d-7b25c5ee775a'</span>

<span class="comment">// Generate a v4 (random) id</span>
uuid.v4(); <span class="comment">// -&gt; '110ec58a-a0f2-4ac4-8393-c866d813b8d1'</span>
</code></pre>
<h2 id="API">API</h2><h3 id="uuid-v1([options_[,_buffer_[,_offset]]])">uuid.v1([<code>options</code> [, <code>buffer</code> [, <code>offset</code>]]])</h3><p>Generate and return a RFC4122 v1 (timestamp-based) UUID.</p>
<ul>
<li><p><code>options</code> - (Object) Optional uuid state to apply. Properties may include:</p>
<ul>
<li><code>node</code> - (Array) Node id as Array of 6 bytes (per 4.1.6). Default: Randomnly generated ID.  See note 1.</li>
<li><code>clockseq</code> - (Number between 0 - 0x3fff) RFC clock sequence.  Default: An internally maintained clockseq is used.</li>
<li><code>msecs</code> - (Number | Date) Time in milliseconds since unix Epoch.  Default: The current time is used.  See note 2.</li>
<li><code>nsecs</code> - (Number between 0-9999) additional time, in 100-nanosecond. Ignored if <code>msecs</code> is unspecified. Default: internal uuid counter is used, as per 4.2.1.2.</li>
</ul>
</li>
<li><p><code>buffer</code> - (Array | Buffer) Array or buffer where UUID bytes are to be written.</p>
</li>
<li><code>offset</code> - (Number) Starting index in <code>buffer</code> at which to begin writing.</li>
</ul>
<p>Returns <code>buffer</code>, if specified, otherwise the string form of the UUID</p>
<p>Notes:</p>
<ol>
<li>The randomly generated node id is only guaranteed to stay constant for the lifetime of the current JS runtime. (Future versions of this module may use persistent storage mechanisms to extend this guarantee.)</li>
<li>Specifying the <code>msecs</code> option bypasses the internal logic for ensuring id uniqueness.  In this case you may want to also provide <code>clockseq</code> and <code>nsecs</code> options as well.</li>
</ol>
<p>Example: Generate string UUID with fully-specified options</p>
<pre><code class="javascript">uuid.v1({
  node: [<span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xab</span>],
  clockseq: <span class="number">0x1234</span>,
  msecs: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011-11-01'</span>).getTime(),
  nsecs: <span class="number">5678</span>
});   <span class="comment">// -&gt; "710b962e-041c-11e1-9234-0123456789ab"</span>
</code></pre>
<p>Example: In-place generation of two binary IDs</p>
<pre><code class="javascript"><span class="comment">// Generate two ids in an array</span>
<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">32</span>); <span class="comment">// -&gt; []</span>
uuid.v1(<span class="literal">null</span>, arr, <span class="number">0</span>);   <span class="comment">// -&gt; [02 a2 ce 90 14 32 11 e1 85 58 0b 48 8e 4f c1 15]</span>
uuid.v1(<span class="literal">null</span>, arr, <span class="number">16</span>);  <span class="comment">// -&gt; [02 a2 ce 90 14 32 11 e1 85 58 0b 48 8e 4f c1 15 02 a3 1c b0 14 32 11 e1 85 58 0b 48 8e 4f c1 15]</span>

<span class="comment">// Optionally use uuid.unparse() to get stringify the ids</span>
uuid.unparse(buffer);                 <span class="comment">// -&gt; '02a2ce90-1432-11e1-8558-0b488e4fc115'</span>
uuid.unparse(buffer, <span class="number">16</span>)              <span class="comment">// -&gt; '02a31cb0-1432-11e1-8558-0b488e4fc115'</span>
</code></pre>
<h3 id="uuid-v4([options_[,_buffer_[,_offset]]])">uuid.v4([<code>options</code> [, <code>buffer</code> [, <code>offset</code>]]])</h3><p>Generate and return a RFC4122 v4 UUID.</p>
<ul>
<li><p><code>options</code> - (Object) Optional uuid state to apply. Properties may include:</p>
<ul>
<li><code>random</code> - (Number[16]) Array of 16 numbers (0-255) to use in place of randomly generated values</li>
</ul>
</li>
<li><p><code>buffer</code> - (Array | Buffer) Array or buffer where UUID bytes are to be written.</p>
</li>
<li><code>offset</code> - (Number) Starting index in <code>buffer</code> at which to begin writing.</li>
</ul>
<p>Returns <code>buffer</code>, if specified, otherwise the string form of the UUID</p>
<p>Example: Generate string UUID with fully-specified options</p>
<pre><code class="javascript">uuid.v4({
  random: [
    <span class="number">0x10</span>, <span class="number">0x91</span>, <span class="number">0x56</span>, <span class="number">0xbe</span>, <span class="number">0xc4</span>, <span class="number">0xfb</span>, <span class="number">0xc1</span>, <span class="number">0xea</span>,
    <span class="number">0x71</span>, <span class="number">0xb4</span>, <span class="number">0xef</span>, <span class="number">0xe1</span>, <span class="number">0x67</span>, <span class="number">0x1c</span>, <span class="number">0x58</span>, <span class="number">0x36</span>
  ]
});
<span class="comment">// -&gt; "109156be-c4fb-41ea-b1b4-efe1671c5836"</span>
</code></pre>
<p>Example: Generate two IDs in a single buffer</p>
<pre><code class="javascript"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">32</span>); <span class="comment">// (or 'new Buffer' in node.js)</span>
uuid.v4(<span class="literal">null</span>, buffer, <span class="number">0</span>);
uuid.v4(<span class="literal">null</span>, buffer, <span class="number">16</span>);
</code></pre>
<h3 id="uuid-parse(id[,_buffer[,_offset]])">uuid.parse(id[, buffer[, offset]])</h3><h3 id="uuid-unparse(buffer[,_offset])">uuid.unparse(buffer[, offset])</h3><p>Parse and unparse UUIDs</p>
<ul>
<li><code>id</code> - (String) UUID(-like) string</li>
<li><code>buffer</code> - (Array | Buffer) Array or buffer where UUID bytes are to be written. Default: A new Array or Buffer is used</li>
<li><code>offset</code> - (Number) Starting index in <code>buffer</code> at which to begin writing. Default: 0</li>
</ul>
<p>Example parsing and unparsing a UUID string</p>
<pre><code class="javascript"><span class="keyword">var</span> bytes = uuid.parse(<span class="string">'797ff043-11eb-11e1-80d6-510998755d10'</span>); <span class="comment">// -&gt; &lt;Buffer 79 7f f0 43 11 eb 11 e1 80 d6 51 09 98 75 5d 10&gt;</span>
<span class="keyword">var</span> string = uuid.unparse(bytes); <span class="comment">// -&gt; '797ff043-11eb-11e1-80d6-510998755d10'</span>
</code></pre>
<h3 id="uuid-noConflict()">uuid.noConflict()</h3><p>(Browsers only) Set <code>uuid</code> property back to it’s previous value.</p>
<p>Returns the node-uuid object.</p>
<p>Example:</p>
<pre><code class="javascript"><span class="keyword">var</span> myUuid = uuid.noConflict();
myUuid.v1(); <span class="comment">// -&gt; '6c84fb90-12c4-11e1-840d-7b25c5ee775a'</span>
</code></pre>
<h2 id="Deprecated_APIs">Deprecated APIs</h2><p>Support for the following v1.2 APIs is available in v1.3, but is deprecated and will be removed in the next major version.</p>
<h3 id="uuid([format_[,_buffer_[,_offset]]])">uuid([format [, buffer [, offset]]])</h3><p>uuid() has become uuid.v4(), and the <code>format</code> argument is now implicit in the <code>buffer</code> argument. (i.e. if you specify a buffer, the format is assumed to be binary).</p>
<h3 id="uuid-BufferClass">uuid.BufferClass</h3><p>The class of container created when generating binary uuid data if no buffer argument is specified.  This is expected to go away, with no replacement API.</p>
<h2 id="Testing">Testing</h2><p>In node.js</p>
<pre><code>&gt; <span class="built_in">cd</span> <span class="built_in">test</span>
&gt; node uuid.js
</code></pre><p>In Browser</p>
<pre><code><span class="keyword">open</span> <span class="keyword">test</span>/<span class="keyword">test</span>.html
</code></pre><h3 id="Benchmarking">Benchmarking</h3><p>Requires node.js</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> <span class="keyword">uuid</span> <span class="keyword">uuid</span>-js
node test/<span class="keyword">benchmark</span>.js</span>
</code></pre><p>For a more complete discussion of node-uuid performance, please see the <code>benchmark/README.md</code> file, and the <a href="https://github.com/broofa/node-uuid/wiki/Benchmark">benchmark wiki</a></p>
<p>For browser performance <a href="http://jsperf.com/node-uuid-performance">checkout the JSPerf tests</a>.</p>
<h2 id="Release_notes">Release notes</h2><p>v1.3: Includes</p>
<ul>
<li>Support for version 1 ids, thanks to <a href="https://github.com/ctavan">@ctavan</a>!</li>
<li>Support for node.js crypto API</li>
<li>De-emphasizing performance in favor of a) cryptographic quality PRNGs where available and b) more manageable code</li>
</ul>
